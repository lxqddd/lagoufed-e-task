# 简答题

## 1. 当我们点击按钮的时候动态给 data 增加的成员是否是响应式数据，如果不是的话，如何把新增成员设置成响应式数据，它的内部原理是什么。

```javascript
let vm = new Vue({
    el: '#el',
      data: {
        o: 'object',
        dog: {}
      },
      method: {
        clickHandler () {
      // 该 name 属性是否是响应式的
      this.dog.name = 'Trump'
    }
  }
})
```

解答：不是响应式的, 响应式对象和响应式数组是指在`vue`初始化时期，利用`Object.defineProperty()`方法对其进行监听，这样在修改数据时会及时体现在页面上。

如果想将其转化为响应是数据，可以利用`Vue.$set()`进行过设置，或者是给dog的属性name设置一个初始值，具体原因如下：

```javascript
let vm = new Vue({
    el: '#app',
    data: {
        msg: 'object',
        dog: {
            name: ''
        }
    },
    method: {
        clickHandler() {
            // 该 name 属性是否是响应式的
            this.dog.name = 'Trump'
        }
    }
})
```

原因：`vm[key]`的`setter `操作会触发` data[key] `的 `setter `操作，`data[key]` 的 `setter `操作会 `walk `这个新的值（`walk`方法是给data里的对象类型的值设置响应式），而题目中的 data 的 dog 是个空对象，没有任何属性，所以初始化 `Vue `实例的时候，在给 dog 设置 proxy 的时候没有任何属性有 `getter `和 `setter `方法，所以在点击按钮动态的给 dog 添加 name 属性，并设置值的时候是不会触发 dog 对象下的属性 name 的 `setter `方法，故不是响应式数据。而给 dog 对象添加了 name 的初始值后，dog 对象的 name 属性就有了 `getter `和 `setter `方法，故可以实现响应式。

## 2、请简述 Diff 算法的执行过程

1. patch函数比较oldVnode和Vnode，是否相同即函数sameVnode(oldVnode, Vnode)，并返回两种结果：
   1. true： 执行pathchVnode
   2. false： 用Vnode替换OldVnode
2. patchVnode执行以下事情
   1. 找到真实的dom，即oldVnode.el
   2. 判断Vnode和oldVnode是否是同一个对象，如果是，直接返回
   3. 如果他们都有文本节点并且不相等，那么将el的文本节点设置为Vnode的文本
   4. 如果oldVnode有子节点Vnode的没有，删除el的子节点
   5. 如果oldVnode的没有子节点，Vnode有子节点，将Vnode的子节点转变成真实dom并插入到el中
   6. 如果他们都有子节点，执行updateChildren即diff算法
3. updateChildren，执行以下事情
   1. 将Vnode和oldVnode的子节点提取出来，分别存储在Vch和oldCh中
   2. oldCh和Vch各有一个头尾startIdx和endIdx，共4个变量。其中两个相互比较，一共4中方式。如果4中方式都没有匹配，并且设置了key，则使用key进行比较。当发生匹配时，指针向中间靠拢，直到startIdx》endIdx或Vch和oldCh至少一个遍历完了，结束比较。（oldS，oldE表示oldCh的起始和结束指针。S，E表示Vch的起始和结束指针）
      1. 如果oldS和E匹配上了，那么真实dom的第一个节点移动到最后
      2. 如果oldE和S匹配上了，那么真实dom的最后一个节点移动到最前，匹配上的指针向中间靠拢。
      3. 如果4中方式都没有匹配成功，如果没有设置key那么遍历oldCh，和S依次匹配
         1. 找到相同的节点，移动到最前面，然后指针向中间靠拢
         2. 没有找到相同的节点，创建一个新的Vnode放在最前面
      4. 如果4中方式都没有匹配成功，如果设置了key，使用oldCh的可以建立一个hash表，然后使用key去匹配，然后将匹配到的节点移动到最前面，然后指针向中间靠拢