# 简答题

## 1. 请简述`Vue`首次渲染的过程

#### 1. `Vue`初始化过程

1. 首先取出Vue的`$mount`，对`$mount`进行重写,给`$mount`增加新的功能

   ```javascript
   // src/platform/web/entry-runtime-with-compiler.js
   // 保留 Vue实例的 $mount 方法
   const mount = Vue.prototype.$mount
   Vue.prototype.$mount = function (
     el?: string | Element,
     // 非ssr情况下的为false, ssr时候为true
     hydrating?: boolean
   ): Component {
     // 获取el对象
     el = el && query(el)
     ...
   }
   ```

2. 判断是否有`render`选项,如果没有`render`选项,则会把模版`template`取出,把模版编译成`render`函数,接着调用`mount`方法,渲染`DOM`

3. 给Vue增加了一个静态的`compile`方法,作用是把`HTML`字符串编译成`render`函数

   ```javascript
   if (!options.render) {
     let template = options.template
       if (template) {
         ...
       }
   }
   
   Vue.compile = compileToFunctions
   export default Vue
   ```

4. 这个文件主要是通过extend给Vue全局注册了指令和组件,组件是Transition和TransitionGroup,指令是v-model和v-show,接着在Vue的原型上注册了 _patch_ 函数, _patch_ 函数作用是将虚拟DOM转换成真实DOM,在给patch函数赋值的时候会判断是否是浏览器环境

5. 继续找Vue的构造函数

   ```javascript
   // src/platforms/web/runtime/index.js
   
   extend(Vue.options.directives, platformDirectives)
   extend(Vue.options.components, platformComponents)
   
   // 判断是否是浏览器环境
   Vue.prototype.__patch__ = inBrowser ? patch : noop
   ```

#### 2. 初始化静态成员

1. 调用`initGlobalAPI(Vue)`方法,给Vue的构造函数增加静态方法

2. `initGlobalAPI(Vue)` 定义在`src/core/global-api/index.js`

   - 初始化`Vue.config`对象
   - 设置`keep-alive` 组件
   - 注册`Vue.use()`用来注册插件
   - 注册`Vue.mixin()`实现混入
   - 注册`Vue.extend()`基于传入的options返回一个组件的构造函数
   - 注册`Vue.directive()`, `Vue.component()`, `Vue.filter`

   ```javascript
   export function initGlobalAPI (Vue: GlobalAPI) {
     const configDef = {}
     configDef.get = () => config
     if (process.env.NODE_ENV !== 'production') {
       configDef.set = () => {
         warn(
           'Do not replace the Vue.config object, set individual fields instead.'
         )
       }
     }
     // 初始化 Vue.config对象
     Object.defineProperty(Vue, 'config', configDef)
     // exposed util methods.
     // NOTE: these are not considered part of the public API - avoid relying on
     // them unless you are aware of the risk.
     // 这些工具方法不视作全局Api的一部分,除非你已经意识到某些风险,否则不要去依赖他们
     Vue.util = {
       warn,
       extend,
       mergeOptions,
       defineReactive
     }
     // 静态方法 set/delete/nextTick
     Vue.set = set
     Vue.delete = del
     Vue.nextTick = nextTick
     // ...
     Vue.options._base = Vue
     // 设置keep-alive 组件
     extend(Vue.options.components, builtInComponents)
     // 注册Vue.use()用来注册插件
     initUse(Vue)
     // 注册Vue.mixin()实现混入
     initMixin(Vue)
     // 注册Vue.extend()基于传入的options返回一个组件的构造函数
     initExtend(Vue)
     // 注册Vue.directive(), Vue.component(), Vue.filter
     initAssetRegisters(Vue)
   }
   ```

#### 3. 初始化实例成员

- _init()
- 定义在`src/core/instance/index.js`
- 定义了构造函数，调用了`this._init(options)`方法
- 给Vue中混入了常用的实例成员

```javascript
function Vue (options) {
  if (process.env.NODE_ENV !== 'production' &&
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword')
  }
  // 调用 _init()方法
  this._init(options)
}
// 注册vm的_init()方法, 初始化vm
initMixin(Vue)
// 注册vm 的$data/$props/$set/$delete/$watch
stateMixin(Vue)
// 初始化事件相关方法
//$on/$once/$off/$emit
eventsMixin(Vue)
// 初始化生命周期相关的混入方法
// _update/$forceUpdate/$destroy
lifecycleMixin(Vue)
// 混入 render
// $nextTick/_render
renderMixin(Vue)

export default Vue
```

#### 4. 初始化实例成员`init()`

- 当静态成员和实例成员都初始化完成之后,接着调用Vue的构造函数,在构造函数中调用`_init()`方法
- `_init`是在`initMixin`中初始化的,主要对Vue实例初始化

```javascript
// vm的生命周期相关变量初始化
initLifecycle(vm)
// vm的事件监听初始化,父组件绑定在当前组件上的事件
initEvents(vm)
// vm的编译render初始化
// $slots/$scopedSlots/_c/$createElement/$attrs/$listeners
initRender(vm)
// beforeCreate 生命钩子的回调
callHook(vm, 'beforeCreate')
// 把inject的成员注入到vm上
initInjections(vm) // resolve injections before data/props
// 初始化vm的 _props/methods/_data/computed/watch
initState(vm)
// 初始化provide
initProvide(vm) // resolve provide after data/props
// created 生命钩子回调
callHook(vm, 'created')
```

#### 5. 初始化实例成员 `initState()`

```javascript
export function initState (vm: Component) {
  vm._watchers = []
  const opts = vm.$options
  if (opts.props) initProps(vm, opts.props)
  if (opts.methods) initMethods(vm, opts.methods)
  if (opts.data) {
    initData(vm)
  } else {
    observe(vm._data = {}, true /* asRootData */)
  }
  if (opts.computed) initComputed(vm, opts.computed)
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch)
  }
}
```

- 在`instance/state.js`中,首先获取了Vue实例中的$options,然后判断options中是否有props,methods,data以及computed和watch这些属性,如果有的话,通过`initProps`进行初始化
- `initProps(vm, opts.props)`接收了两个参数,一个是Vue实例,一个是Props属性,我们跳转到`initProps`函数中,首先给Vue实例定义了一个
- 紧接着,开始遍历`PropsOptions`的所有属性,它其实就是`initProps`方法中的第二个参数,遍历每个属性,然后通过`defineReactive`注入到Props这个对象上,这个props其实就是vm._props所有的成员都会通过`defineReacttive`转化为get和set,最后在Props对象上存储
- 在开发模式中,如果我们直接给这个属性赋值的话,会发出一个警告
- 生产环境中直接通过`defineReactive`把props中的属性转化成get和set
- 最后判断了props属性是否在Vue实例中存在,不存在通过Proxy这个函数把我们的属性注入到Vue的实例中
- 在 Proxy 中,通过调用`Object.defineProperty(target, key,sharePropertyDefinition)`
- `initProps` 的作用就是把我们的`Props`成员转化成响应式数据,并且注入到`Vue`实例里面中

#### 6. `initMethods`

- 在`initMethods(vm, opts.methods)`中,也是接收两个参数,Vue实例和选项中的methods,首先获取了选项中的Props,接着遍历methods所有属性,接着判断当前的环境是否是开发或者生产开发环境会判断methods是否是functicon
- 接着判断methods方法的名称是否在Props对象中存在,存在就会发送一个警告,警告在属性在Props中已经存在,因为Props和methods最终都要注入到Vue实例上,不能出现同名
- 下面继续判断key是否在Vue中存在,并且调用了`isReserved(key)`,判断我们的key是否以_开头或$开头
  最后把methods注入到Vue实例上来,注入的时候会判断是否是function,如果不是返回noop,是的话把函数返回`bind(methods[key], vm)`
- `initMethods`作用就是把选项的`methods`注入到vue实例,在注入之前,会先判断我们命名是否在`Props`中存在,并且判断了命名的规范,不建议_和$开头

#### 7. `initData(vm)`

- 当options中有data选项时,会调用`initData(vm)`

- 当没有的时候此时会给vm初始化一个_data属性`observe(vm._data = {}, true)`然后调用observe函数,observe是响应式中的一个函数

- 在`initData`中获取了options的data选项,判断了data选项是否是function,如果是调用`getData(data,vm)`接着获取data中的所有属性,同时获取了`props`,`methods`中所有的属性

  ```javascript
  // src/core/instance/state.js
  const keys = Object.keys(data)
  const props = vm.$options.props
  const methods = vm.$options.methods
  ```

- 最后做一个响应式处理

  ```javascript
  observe(data, true)
  ```

- 在`_init`函数的最后,又调用了`$mount`来挂载整个页面

  ```javascript
  // src/core/instance/init.js
  
  if (vm.$options.el) {
    vm.$mount(vm.$options.el)
  }
  
  ```

#### 8. 总结

- 在首次渲染之前,首先进行Vue初始化,初始化实例成员和静态成员
- 当初始化结束之后,要调用Vue的构造函数`new Vue()`,在构造函数中调用了`_init()`方法,这个方法相当于我们整个Vue的入口
- 在`_init`方法中,最终调用了`$mount`,一共有两个`$mount`,第一个定义在`entry-runtime-with-compiler.js`文件中,也就是我们的入口文件`$mount`,这个`$mount()`的核心作用是帮我们把模板编译成render函数，但它首先会判断一下当前是否传入了render选项，如果没有传入的话，它会去获取我们的template选项，如果template选项也没有的话，他会把el中的内容作为我们的模板，然后把模板编译成render函数，它是通过`compileToFunctions()`函数，帮我们把模板编译成render函数的,当把render函数编译好之后，它会把render函数存在我们的`options.render`中。
- 接着会调用`src/platforms/web/runtime/index.js`文件中的`$mount`方法,在这个中首先会重新获取el，因为如果是运行时版本的话，是不会走`entry-runtime-with-compiler.js`这个入口中获取el，所以如果是运行时版本的话，我们会在`runtime/index.js`的`$mount()`中重新获取el。
- 接下来调用`mountComponent()`,这个方法在`src/core/instance/lifecycle.js`中定义的，在`mountComponent()`中，首先会判断render选项，如果没有render选项，但是我们传入了模板，并且当前是开发环境的话会发送一个警告，目的是如果我们当前使用运行时版本的Vue,而且我们没有传入render,但是传入了模版,告诉我们运行时版本不支持编译器。接下来会触发`beforeMount`这个生命周期中的钩子函数，也就是开始挂载之前。
- 然后定义了`updateComponent()`，在这个函数中，调用`vm._render`和`vm._update`，`vm._render`的作用是生成虚拟DOM，`vm._update`的作用是将虚拟DOM转换成真实DOM，并且挂载到页面上
- 创建`Watcher`对象，在创建`Watcher`时，传递了`updateComponent`这个函数，这个函数最终是在`Watcher`内部调用的。在`Watcher`内部会用了get方法，当`Watcher`创建完成之后,会触发生命周期中的`mounted`钩子函数,在get方法中，会调用`updateComponent()`
- 挂载结束，最终返回Vue实例。

## 2. 请简述 Vue 响应式原理。

Vue 使用观察者模式来对其数据进行响应式处理，过程如下：

#### 1. 创建观察者：

- 在创建 Vue 实例时，调用的 `this._init(options) `中会执行` initInjections(vm)`、`initState(vm)`，这两个方法中分别会对 inject 的成员、本实例的 props 和 data 进行响应式处理
- `initInjections(vm)` 中会遍历 inject 的成员，通过 `defineReactive(vm, key, result[key])` 将每个成员转换成响应式属性（即劫持 getter/setter）
- `initState(vm) `中调用 `initProps(vm, opts.props)`，其中编辑 props 属性，通过 `**defineReactive(props, key, value)** `将属性转换成getter、setter，然后存入 `props（也是 vm._props）`中
- `initState(vm)` 中调用 `initData(vm, opts.props)`，其中调用 `observe(data, true /* asRootData */)` 对 data 进行响应式处理

- `defineReactive(obj, key, val, customSetter?, shallow?)`
  - 会将传入的 key 换成响应式属性，即其劫持 getter/setter （ Object.defineProperty( obj, key, { ..., get(){...}, set(){...} } ) ）
  - 为每个属性 key  生成一个 Dep 对象 `dep(const dep = new Dep())`；dep 会在 getter 中收集依赖（即相应属性的 Watcher 对象），在 setter 中调用`dep.notify()`派发更新；
  - 在需要递归观察子对象时，会调用 `observe(val)`，若 val 是个对象，则会为这个对象创建一个 Observer 对象，并返回。

- `observe (value, asRootData?)`
  - 判断 value 是否是对象，不是对象就返回
  - 是对象，则这个对象可称之为 **观测对象** ，然后为这个对象创建一个 Observer 对象 ：`ob = new Observer(value)`，并返回 ob（在 `defineReactive `中，这个返回的 ob 会在 getter 中收集依赖相应的依赖）
  - Observer 构造函数中，会新建一个 Dep 对象 dep，这里的 dep 是为传入的 **观测对象**（进行响应式处理的对象）收集依赖（Watcher）；与 `defineReactive `中的 dep 不一样
  - 将 Observer 实例挂载到 **观测对象** 的 \_\_ob\_\_ 属性：`def(value, '\_\_ob\_\_', this)`
  - 若 value 不是数组，则执行 `this.walk(value)` 方法，遍历 value 中的每一个属性，然后调用 `defineReactive(obj, keys[i])`
  - 若 value 是数组
    -  Vue 并没有对数组对象的索引调用 `defineReactive `来生成 getter/setter，而是重写了原生数组中会更改原数组的方法，调用这些新方法后，数组对象对应的 dep 对象会调用 `dep.notify` 方法来驱动视图的更新
    - 重写的数组方法：'push'， 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'
    - 重写数组方法后，调用 `this.observeArray(value)`，作用是当数组中的元素存在对象时，为数组中的每一个对象创建一个 observer 实例

至此，创建观察者结束

#### 2. 依赖的收集：

- 在进行挂载时（ 调用 \$mount() ），会执行 `mountComponent` 方法，其中会创建一个渲染 Watcher 对象
- 渲染 Watcher 对象构造函数的最后会执行 get() 方法，get() 中会先执行 `pushTarget(this)`，`pushTarget `中则会将 **`Dep.target` 设置为该 `watcher（Dep.target = target）`**
- 然后调用 `this.getter.call(vm, vm)`，即执行了 `vm.\_update(vm.\_render(), hydrating)`，而 `vm.\_render()` 中执行 `render.call(vm._renderProxy, vm.\$createElement)` 以生成 vnode，这个生成 VNode 的过程中，会触发 **相应的响应式数据的 getter** ，然后其中的 `dep.depend()` 则会收集当前实例 watcher  

当生成完 VNode 后，就完成了响应式数据的的依赖收集

#### 3. 通知的发送：

但修改某个响应式数据时，会触发该数据的 setter

- 如果新值是对象，且需要递归观察子对象时执行 `childOb = !shallow && observe(newVal)`，将新增也进行响应式处理
- 调用 `dep.notify()` 派发更新，notify 会调用每个订阅者（watcher）的 update 方法实现更新
- watcher 的  update  中使用 `queueWatcher()` 判断 watcher 是否被处理，若没有，则把 watcher 添加进 queue 队列中，并调用 `flushSchedulerQueue()`
- `flushSchedulerQueue()` 中先触发 `beforeUpdate `钩子函数，然后调用 `watcher.run()`
- **`watcher.run()` 中会调用 get() 方法，get 中执行 getter，而 getter 就是传入的 `updateComponent` 方法，`updateComponent` 中执行 `vm._update(vm._render(), hydrating)`，如此就完成了视图的更新**
- 然后 `flushSchedulerQueue()` 后续代码中 还原更新步骤的初始状态、触发 `actived `钩子函数、触发 updated 钩子函数

## 3. 请简述虚拟 DOM 中 Key 的作用和好处。

- Key 是用来优化 Diff 算法的。Diff算法核心在于同层次节点比较，Key 就是用于在比较同层次新、旧节点时，判断其是否相同。
- Key 一般用于生成一列同类型节点时使用，这种情况下，当修改这些同类型节点的某个内容、变更位置、删除、添加等时，此时界面需要更新视图，Vue 会调用 patch 方法通过对比新、旧节点的变化来更新视图。其从根节点开始若新、旧 VNode 相同，则调用 `patchVnode`
- `patchVnode `中若新节点没有文本，且新节点和旧节点都有有子节点，则需对子节点进行 Diff 操作，即调用 `updateChildren`，Key 就在 `updateChildren `起了大作用
- `updateChildren `中会遍历对比上步中的新、旧节点的子节点，并按 Diff 算法通过 `sameVnode `来判断要对比的节点是否相同
- 若这里的子节点未设置 Key，则此时的每个新、旧子节点在执行 `sameVnode `时会判定相同，然后再次执行一次 `patchVnode `来对比这些子节点的子节点
- 若设置了 Key，当执行 `sameVnode `
- 若 Key 不同 `sameVnode `返回 false，然后执行后续判断；
- 若 Key 相同 `sameVnode `返回 true，然后再执行 `patchVnode `来对比这些子节点的子节点

即，使用了 Key 后，可以优化新、旧节点的对比判断，减少了遍历子节点的层次，少使用很多次 `patchVnode `

## 4. 请简述 Vue 中模板编译的过程

#### Vue 模板编译入口文件执行过程

- 在完整版 Vue 中，`src/platforms/web/entry-runtime-with-compiler.js` 里先保留 Vue 实例的 `$mount` 方法，然后重写该 `$mount` 方法，这个重写的方法就是完整版 Vue 中的模板编译器，其中在 `$options` 上挂载了模板编译后生成的 render 函数。
- `$options` 上的 render 函数是由 `compileToFunctions(template, options, vm)` 这个函数生成，即将 template 转换成了 render 函数。所以这里就是完成了首次加载时对模板的编译。

生成 render 函数的相关函数的调用过程如下：

#### 第一步

调用 `compileToFunctions(template, options, vm)`

```javascript
// src/platforms/web/entry-runtime-with-compiler.js 
// 把 template 转换成 render 函数
const { render, staticRenderFns } = compileToFunctions(template, {
  outputSourceRange: process.env.NODE_ENV !== 'production',
  shouldDecodeNewlines,
  shouldDecodeNewlinesForHref,
  delimiters: options.delimiters,
  comments: options.comments
}, this)
options.render = render
options.staticRenderFns = staticRenderFns
```

#### 第二步

- `compileToFunctions `是由 `src/platforms/web/compiler/index.js` 里的 `createCompiler(baseOptions)` 生成的。`baseOptions `里是一些关于指令、模块、HTML标签相关的方法，这里不予关心。
- 所以 **第一步** 中 `compileToFunctions`是这里的 `createCompiler`返回的函数。

```javascript
// src/platforms/web/compiler/index.js

import { baseOptions } from './options'
import { createCompiler } from 'compiler/index'

const { compile, compileToFunctions } = createCompiler(baseOptions)

export { compile, compileToFunctions }

```

#### 第三步

- `createCompiler`来自于 `src/compiler/index.js`，其中调用了 `createCompilerCreator(function baseCompile (template, options))` 方法
- 所以 **第二步** 中的 `createCompiler `来自于这里的 `createCompilerCreator `返回的函数，`createCompilerCreator `中传入 函数 `baseCompile`作为参数
- 那么 **第一步** 中的 `compileToFunctions`就是这里的 `createCompilerCreator`返回的函数执行（即执行 `createCompiler(baseOptions)`）后返回的函数

```javascript
// src/compiler/index.js

export const createCompiler = createCompilerCreator(function baseCompile (
  template: string,
  options: CompilerOptions
): CompiledResult {
  // 把模板转换成 ast 抽象语法树
  // 抽象语法树，用来以树形的方式描述代码结构
  const ast = parse(template.trim(), options)
  if (options.optimize !== false) {
    // 优化抽象语法树
    optimize(ast, options)
  }
  // 把抽象语法树生成字符串形式的 js 代码
  const code = generate(ast, options)
  return {
    ast,
    // 渲染函数
    render: code.render,
    // 静态渲染函数，生成静态 VNode 树
    staticRenderFns: code.staticRenderFns
  }
})
```

#### 第四步

`createCompilerCreator`来自于 `src/compiler/create-compiler.js`

```javascript
// src/compiler/create-compiler.js
export function createCompilerCreator (baseCompile: Function): Function {
    return function createCompiler (baseOptions: CompilerOptions) {
        function compile (
          template: string,
          options?: CompilerOptions
        ): CompiledResult {
            const finalOptions = Object.create(baseOptions)
            ....
            const compiled = baseCompile(template.trim(), finalOptions)
            ...
            return compiled
        }
        
        return {
          compile,
          compileToFunctions: createCompileToFunctionFn(compile)
        }
    }
}
```

可以看出这个函数返回了 `createCompiler(baseOptions)` 函数，则往上推可知 **第二步** 中的

```javascript
// src/platforms/web/compiler/index.js

const { compile, compileToFunctions } = createCompiler(baseOptions)
```

- 其实就是执行的这里的 `function createCompiler (baseOptions: CompilerOptions){...}`，这个 `createCompiler`函数里返回了方法 `compile`、`compileToFunctions`
- 方法 `compile`中执行了传入的函数参数 `baseCompile`，这个 `baseCompile `是 **第三步** 中传入的，其返回值为 `ast`、`render`、`staticRenderFns`
- 而方法 `compileToFunctions `正是 **第一步** 中调用的 `compileToFunctions(template, options, vm)`，其来自于 `createCompileToFunctionFn(compile)`

#### 第五步

`createCompileToFunctionFn `来自于 `src/compiler/to-function.js`

```javascript
// src/compiler/to-function.js

export function createCompileToFunctionFn (compile: Function): Function {
    return function compileToFunctions (
        template: string,
        options?: CompilerOptions,
        vm?: Component
      ): CompiledFunctionResult {
        ...
        
        // 1. 读取缓存中的 CompiledFunctionResult 对象，如果有直接返回
        const key = options.delimiters
          ? String(options.delimiters) + template
          : template
        if (cache[key]) {
          return cache[key]
        }
        
        // 2. 把模板编译为编译对象(render, staticRenderFns)，字符串形式的js代码
        const compiled = compile(template, options)
        
        // 3. 把字符串形式的js代码转换成js方法
        res.render = createFunction(compiled.render, fnGenErrors)
        res.staticRenderFns = compiled.staticRenderFns.map(code => {
          return createFunction(code, fnGenErrors)
        })
        
        // 4. 缓存并返回res对象(render, staticRenderFns方法)
        return (cache[key] = res)
    }
}
```

`createCompileToFunctionFn `返回函数 `compileToFunctions`，即 **第四步** 中 `createCompiler `函数返回的 `compileToFunctions`，所以是 **第一步** 中调用的 `compileToFunctions `就是在执行这里的 `compileToFunctions`。

#### 总结过程

- 执行 `src/platforms/web/entry-runtime-with-compiler.js` 中的` compileToFunctions(template, options, vm)`

- 执行` src/compiler/to-function.js` 中的 `compileToFunctions`，`compileToFunctions`中调用 `compile(template, options)`

- 执行 `src/compiler/create-compiler.js` 中的 `compile`，`compile `中调用 `baseCompile(template.trim(), finalOptions)`

- 执行 `src/compiler/index.js` 传入 `createCompilerCreator`中的函数参数 `baseCompile(template, options)`，返回 `ast`、`render`、`staticRenderFns`

- `src/compiler/create-compiler.js` 中 `const compiled = { ast、render、staticRenderFns }`，返回 `compiled`

- `src/compiler/to-function.js` 中返回 res，即返回 `render`, `staticRenderFns `方法

- `src/platforms/web/entry-runtime-with-compiler.js` 获取 `render`、`staticRenderFns`

