### 说一下Http缓存策略，有什么区别，分别解决了什么问题

1. **浏览器缓存策略**
- 浏览器每次发起请求时，先在本地缓存中查找结果以及缓存标识，根据缓存标识来判断是否使⽤本地缓存。如果缓存有效，则使⽤本地缓存；否则，则向服务器发起请求并携带缓存标识。
  1. 根据是否需向服务器发起HTTP请求，将缓存过程划分为两个部分：强制缓存和协商缓存，强缓优先于协商缓存。
  - 强缓存，服务器通知浏览器⼀个缓存时间，在缓存时间内，下次请求，直接⽤缓存，不在时间内，执⾏⽐较缓存策略。
  - 协商缓存，让客户端与服务器之间能实现缓存⽂件是否更新的验证、提升缓存的复⽤率，将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使⽤缓存。
 
  2. HTTP缓存都是从第⼆次请求开始的：
  - 第⼀次请求资源时，服务器返回资源，并在response header中回传资源的缓存策略；
  - 第⼆次请求时，浏览器判断这些请求参数，击中强缓存就直接200，否则就把请求参数加到request header头中传给服务器，看是否击中协商缓存，击中则返回304，否则服务器会返回新的资源。

2. **强缓存**
  1. 强缓存命中则直接读取浏览器本地的资源，在network中显示的是from memory或者from disk
  2. 控制强制缓存的字段有：Cache-Control（http1.1）和Expires（http1.0）
  3. Cache-control是⼀个相对时间，⽤以表达⾃上次请求正确的资源之后的多少秒的时间段内缓存有效。
  4. Expires是⼀个绝对时间。⽤以表达在这个时间点之前发起请求可以直接从浏览器中读取数据，⽽⽆需发起请求
  5. Cache-Control的优先级⽐Expires的优先级⾼。前者的出现是为了解决Expires在浏览器时间被⼿动更改导致缓存判断错误的问题。如果同时存在则使⽤Cache-control。

3. **强缓存-expires**
  1. 该字段是服务器响应消息头字段，告诉浏览器在过期时间之前可以直接从浏览器缓存中存取数据。
  2. Expires 是 HTTP 1.0 的字段，表示缓存到期时间，是⼀个绝对的时间 (当前时间+缓存时间)。在响应消息头中，设置这个字段之后，就可以告诉浏览器，在未过期之前不需要再次请求。
  3. 由于是绝对时间，⽤户可能会将客户端本地的时间进⾏修改，⽽导致浏览器判断缓存失效，重新请求该资源。此外，即使不考虑修改，时差或者误差等因素也可能造成客户端与服务端的时间不⼀致，致使缓存失效。
  4. 优势特点
    1. HTTP 1.0 产物，可以在HTTP 1.0和1.1中使⽤，简单易⽤。
    1. 以时刻标识失效时间。
  5. 劣势问题
    1. 时间是由服务器发送的(UTC)，如果服务器时间和客户端时间存在不⼀致，可能会出现问题。
    2. 存在版本问题，到期之前的修改客户端是不可知的。

4. **强缓存-cache-control**
  1. 已知Expires的缺点之后，在HTTP/1.1中，增加了⼀个字段Cache-control，该字段表示资源缓存的最⼤有效时间，在该时间内，客户端不需要向服务器发送请求。
  2. 这两者的区别就是前者是绝对时间，⽽后者是相对时间。下⾯列举⼀些 Cache-control 字段常⽤的值：(完整的列表可以查看MDN)
    1. max-age：即最⼤有效时间。
    2. must-revalidate：如果超过了 max-age 的时间，浏览器必须向服务器发送请求，验证资源是否还有效。
    3. no-cache：不使⽤强缓存，需要与服务器验证缓存是否新鲜。
    4. no-store: 真正意义上的“不要缓存”。所有内容都不⾛缓存，包括强制和对⽐。
    5. public：所有的内容都可以被缓存 (包括客户端和代理服务器， 如 CDN)
    6. private：所有的内容只有客户端才可以缓存，代理服务器不能缓存。默认值。
    7. Cache-control 的优先级⾼于 Expires，为了兼容 HTTP/1.0 和 HTTP/1.1，实际项⽬中两个字段都可以设置。 
  3. 该字段可以在请求头或者响应头设置，可组合使⽤多种指令:
    1. 可缓存性
       1. public：浏览器和缓存服务器都可以缓存⻚⾯信息
       2. private：default，代理服务器不可缓存，只能被单个⽤户缓存
       3. no-cache：浏览器器和服务器都不应该缓存⻚⾯信息，但仍可缓存，只是在缓存前需要向服务器确认资源是否被更改。可配合private，
       4. 过期时间设置为过去时间。
       5. only-if-cache：客户端只接受已缓存的响应
    2. 到期
      1. max-age=：缓存存储的最⼤周期，超过这个周期被认为过期。
      2. s-maxage=：设置共享缓存，⽐如can。会覆盖max-age和expires。
      3. max-stale[=]：客户端愿意接收⼀个已经过期的资源
      4. min-fresh=：客户端希望在指定的时间内获取最新的响应
      5. stale-while-revalidate=：客户端愿意接收陈旧的响应，并且在后台⼀部检查新的响应。时间代表客户端愿意接收陈旧响应的时间⻓度。
      6. stale-if-error=：如新的检测失败，客户端则愿意接收陈旧的响应，时间代表等待时间。
   3.  重新验证和重新加载
      1. must-revalidate：如⻚⾯过期，则去服务器进⾏获取。
      2. proxy-revalidate：⽤于共享缓存。
      3. immutable：响应正⽂不随时间改变
   4. 其他
      1. no-store：绝对禁⽌缓存
      2. no-transform：不得对资源进⾏转换和转变。例如，不得对图像格式进⾏转换。
  4. 优势特点
    1. HTTP 1.1 产物，以时间间隔标识失效时间，解决了Expires服务器和客户端相对时间的问题。
    2. ⽐Expires多了很多选项设置。
  5. 劣势问题
    1. 存在版本问题，到期之前的修改客户端是不可知的

5. **协商缓存**
  1. 协商缓存的状态码由服务器决策返回200或者304
  2. 当浏览器的强缓存失效的时候或者请求头中设置了不⾛强缓存，并且在请求头中设置了If-Modified-Since 或者If-None-Match 的时候，会将这两个属性值到服务端去验证是否命中协商缓存，如果命中了协商缓存，会返回 304状态，加载浏览器缓存，并且响应头会设置 Last-Modified 或者 ETag 属性。
  3. 对⽐缓存在请求数上和没有缓存是⼀致的，但如果是 304 的话，返回的仅仅是⼀个状态码⽽已，并没有实际的⽂件内容，因此 在响应体体积上的节省是它的优化点。
  4. 协商缓存有 2 组字段(不是两个)，控制协商缓存的字段有：Last-Modified/If-Modified-since（http1.0）和Etag/If-None-match（http1.1）
  5. Last-Modified/If-Modified-since表示的是服务器的资源最后⼀次修改的时间；Etag/If-None-match表示的是服务器资源的唯⼀标识，只要资源变化，Etag就会重新⽣成。
  6. Etag/If-None-match的优先级⽐Last-Modified/If-Modified-since⾼。

6. **协商缓存-Last-Modified/If-Modified-since**
  1. 服务器通过 Last-Modified 字段告知客户端，资源最后⼀次被修改的时间，例如 Last-Modified: Mon, 10Nov 2018 09:10:11 GMT
  2. 浏览器将这个值和内容⼀起记录在缓存数据库中。
  3. 下⼀次请求相同资源时时，浏览器从⾃⼰的缓存中找出“不确定是否过期的”缓存。因此在请求头中将上次的 LastModified 的值写⼊到请求头的 If-Modified-Since 字段
  4. 服务器会将 If-Modified-Since 的值与 Last-Modified 字段进⾏对⽐。如果相等，则表示未修改，响应304；反之，则表示修改了，响应 200 状态码，并返回数据。
  5. 优势特点
     1. 不存在版本问题，每次请求都会去服务器进⾏校验。服务器对⽐最后修改时间如果相同则返回304，不同返回200以及资源内容。
  6. 劣势问题
     1. 只要资源修改，⽆论内容是否发⽣实质性的变化，都会将该资源返回客户端。例如周期性重写，这种情况下该资源包含的数据实际上⼀样的。
     2. 以时刻作为标识，⽆法识别⼀秒内进⾏多次修改的情况。 如果资源更新的速度是秒以下单位，那么该缓存是不能被使⽤的，因为它的时间单位最低是秒。
     3. 某些服务器不能精确的得到⽂件的最后修改时间。
     4. 如果⽂件是通过服务器动态⽣成的，那么该⽅法的更新时间永远是⽣成的时间，尽管⽂件可能没有变化，所以起不到缓存的作⽤。
7. **协商缓存-Etag/If-None-match**
   1. 为了解决上述问题，出现了⼀组新的字段 Etag 和 If-None-Match
   2. Etag 存储的是⽂件的特殊标识(⼀般都是 hash ⽣成的)，服务器存储着⽂件的 Etag 字段。之后的流程和Last-Modified ⼀致，只是 Last-Modified 字段和它所表示的更新时间改变成了 Etag 字段和它所表示的⽂件hash，把 If-Modified-Since 变成了 If-None-Match。服务器同样进⾏⽐较，命中返回 304, 不命中返回新资源和 200。
   3. 浏览器在发起请求时，服务器返回在Response header中返回请求资源的唯⼀标识。在下⼀次请求时，会将上⼀次返回的Etag值赋值给If-No-Matched并添加在Request Header中。服务器将浏览器传来的if-no-matched跟⾃⼰的本地的资源的ETag做对⽐，如果匹配，则返回304通知浏览器读取本地缓存，否则返回200和更新后的资源。
   4. Etag 的优先级⾼于 Last-Modified。
   5. 优势特点
      1. 可以更加精确的判断资源是否被修改，可以识别⼀秒内多次修改的情况。
      2. 不存在版本问题，每次请求都回去服务器进⾏校验。
   6. 劣势问题
      1. 计算ETag值需要性能损耗。
      2. 分布式服务器存储的情况下，计算ETag的算法如果不⼀样，会导致浏览器从⼀台服务器上获得⻚⾯内容后到另外⼀台服务器上进⾏验证时现ETag不匹配的情况。